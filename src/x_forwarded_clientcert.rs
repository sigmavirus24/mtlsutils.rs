//! Provides utilities for parsing the X-Forwarded-Client-Cert (a.k.a., XFCC) header generated by
//! Envoy.
//!
//! This can parse an XFCC header generated by Envoy.
use std::str::FromStr;

/// A Name is a parsed representation of the Subject attribute of XForwardedClientCert.
#[derive(Default, Debug, PartialEq)]
pub struct Name {
    // https://www.rfc-editor.org/rfc/rfc1779#section-2.2
    country: Option<Vec<String>>,
    organization: Option<Vec<String>>,
    organizational_unit: Option<Vec<String>>,
    locality: Option<Vec<String>>,
    province: Option<Vec<String>>,
    street_address: Option<Vec<String>>,
    serial_number: Option<String>,
    common_name: Option<String>,
}

impl Name {
    fn append_country(&mut self, country: &str) {
        match &mut self.country {
            Some(countries) => countries.push(country.to_string()),
            None => self.country = Some(vec![country.to_string()]),
        }
    }

    fn append_organization(&mut self, org: &str) {
        match &mut self.organization {
            Some(organizations) => organizations.push(org.to_string()),
            None => self.organization = Some(vec![org.to_string()]),
        }
    }

    fn append_organizational_unit(&mut self, ou: &str) {
        match &mut self.organizational_unit {
            Some(ous) => ous.push(ou.to_string()),
            None => self.organizational_unit = Some(vec![ou.to_string()]),
        }
    }
    fn append_locality(&mut self, locality: &str) {
        match &mut self.locality {
            Some(localities) => localities.push(locality.to_string()),
            None => self.locality = Some(vec![locality.to_string()]),
        }
    }
    fn append_province(&mut self, province: &str) {
        match &mut self.province {
            Some(provinces) => provinces.push(province.to_string()),
            None => self.province = Some(vec![province.to_string()]),
        }
    }
    fn append_street_address(&mut self, address: &str) {
        match &mut self.street_address {
            Some(street_addresses) => street_addresses.push(address.to_string()),
            None => self.street_address = Some(vec![address.to_string()]),
        }
    }
}

impl FromStr for Name {
    type Err = ParseError;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        // Subject=\"/C=US/ST=CA/L=San Francisco/OU=Lyft/CN=Test Client\"
        let s = s.trim_start_matches('/').trim_end_matches('/');
        let mut name = Name::default();
        for attribute_and_value in quote_aware_split(s, '/', 0)? {
            let pieces: Vec<&str> = attribute_and_value.as_str().splitn(2, '=').collect();
            let attribute = pieces[0];
            let value = pieces[1];
            if value.is_empty() {
                continue;
            }
            match attribute.to_lowercase().as_str() {
                "c" => name.append_country(value),
                "o" => name.append_organization(value),
                "ou" => name.append_organizational_unit(value),
                "l" => name.append_locality(value),
                "st" => name.append_province(value),
                "cn" => name.common_name = Some(value.to_string()),
                "street" => name.append_street_address(value),
                _ => return Err(ParseError::NameParseFailed(attribute_and_value)),
            }
        }
        Ok(name)
    }
}

// XForwardedClientCert represents a single item in the possible list of certificates present in
// the `X-Forwarded-Client-Cert` header. See also [Envoy's docs].
//
// [Envoy's docs]: https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_conn_man/headers#x-forwarded-client-cert
#[derive(Debug, PartialEq)]
pub struct XForwardedClientCert {
    by: String,
    hash: Option<String>,
    cert: Option<String>,
    chain: Option<String>,
    subject: Option<String>,
    uri: Option<Vec<String>>,
    dns: Option<Vec<String>>,
}

impl XForwardedClientCert {
    // Retrieve the By= attribute from an X-Forwaded-Client-Cert item. `By=` is the Subject
    // Alternative Name of the "current" proxy's certificate.
    pub fn get_by(&self) -> &str {
        &self.by
    }

    // Retrieve the Hash= attribute from an X-Forwaded-Client-Cert item. `Hash=` is the SHA 256
    // digest of the "current" client certificate.
    pub fn get_hash(&self) -> Option<&str> {
        match &self.hash {
            Some(hash) => Some(hash),
            None => None,
        }
    }

    // Retrieve the Cert= attribute from an X-Forwaded-Client-Cert item. `Cert=` is the url-encoded
    // PEM string of the "current" client certificate.
    pub fn get_cert_pem(&self) -> Option<&str> {
        match &self.cert {
            Some(cert_pem) => Some(cert_pem),
            None => None,
        }
    }

    // Retrieve the Chain= attribute from an X-Forwaded-Client-Cert item. `Chain=` is the entire
    // client certificate chain (including the leaf certificate) in URL encoded PEM format.
    pub fn get_cert_chain_pem(&self) -> Option<&str> {
        match &self.chain {
            Some(chain_pem) => Some(chain_pem),
            None => None,
        }
    }

    // Retrieve the Subject= attribute from an X-Forwarded-Client-Cert item. `Subject=` is the
    // Subject field of the current client certificate.
    pub fn get_subject(&self) -> Option<&str> {
        match &self.subject {
            Some(subject) => Some(subject),
            None => None,
        }
    }

    // Retrieve the URI= attribute from an X-Forwaded-Client-Cert item. `URI=` contains the URI
    // type Subject Alternative Name field of the current client certificate. A client certificate
    // may contain multiple URI type Subject Alternative Names, each will be a separate key-value
    // pair.
    pub fn get_all_uris(&self) -> Option<&Vec<String>> {
        match &self.uri {
            Some(uris) => Some(uris),
            None => None,
        }
    }

    // Retrieve the DNS= attribute from an X-Forwaded-Client-Cert item. `DNS=` contains the DNS
    // type Subject Alternative Name field of the current client certificate. A client certificate
    // may contain multiple DNS type Subject Alternative Names, each will be a separate key-value
    // pair.
    pub fn get_all_dns(&self) -> Option<&Vec<String>> {
        match &self.dns {
            Some(dns) => Some(dns),
            None => None,
        }
    }

    fn append_uri(&mut self, uri: &str) {
        match self.uri.clone() {
            Some(mut uris) => {
                uris.push(String::from(uri));
                self.uri = Some(uris.to_vec());
            }
            None => {
                self.uri = Some(vec![String::from(uri)]);
            }
        }
    }

    fn append_dns(&mut self, dns: &str) {
        match self.dns.clone() {
            Some(mut dns_values) => {
                dns_values.push(String::from(dns));
                self.dns = Some(dns_values.to_vec());
            }
            None => {
                self.dns = Some(vec![String::from(dns)]);
            }
        }
    }
}

#[derive(Debug, PartialEq)]
pub enum ParseError {
    InvalidFormat,
    InvalidField(String),
    QuotedStringNotTerminated,
    NameParseFailed(String),
}

fn quote_aware_split(
    value: &str,
    delimiter: char,
    limit: usize,
) -> Result<Vec<String>, ParseError> {
    let mut elements: Vec<String> = Vec::new();
    let mut buffer = String::new();
    let mut in_quotes = false;
    let mut in_escape = false;
    let mut first_match = false;
    for c in value.chars() {
        if c == delimiter && !in_quotes && !first_match {
            elements.push(buffer.clone());
            buffer.truncate(0);
            in_escape = false;
            if limit > 0 {
                first_match = true;
            }
            continue;
        }

        if c == '"' {
            if in_quotes {
                if !in_escape {
                    in_quotes = false;
                }
            } else {
                in_quotes = true;
            }
            in_escape = false;
            buffer.push(c);
            continue;
        }

        if c == '\\' && !in_escape {
            in_escape = true;
            buffer.push(c);
            continue;
        }

        in_escape = false;
        buffer.push(c);
    }
    elements.push(buffer);
    match in_quotes {
        true => Err(ParseError::QuotedStringNotTerminated),
        false => Ok(elements),
    }
}

// Provided a value of X-Forwaded-Client-Cert, this will return a Vec of the parsed
// XForwardedClientCert header items.
pub fn parse_xfcc_list(value: &str) -> Result<Vec<XForwardedClientCert>, ParseError> {
    let mut xfccs: Vec<XForwardedClientCert> = Vec::new();
    for xfcc_string in quote_aware_split(value, ',', 0).unwrap() {
        match parse_single_xfcc(&xfcc_string) {
            Ok(xfcc) => xfccs.push(xfcc),
            Err(e) => return Err(e),
        }
    }
    Ok(xfccs)
}

// Provided a single element from the X-Forwarded-Client-Cert header, this will return the
// individual parsed XForwardedClientCert.
pub fn parse_single_xfcc(value: &str) -> Result<XForwardedClientCert, ParseError> {
    let attributes = quote_aware_split(value, ';', 0)?;
    let mut parsed_xfcc = XForwardedClientCert {
        by: String::new(),
        hash: None,
        cert: None,
        chain: None,
        subject: None,
        uri: None,
        dns: None,
    };
    for attribute in attributes {
        let pieces: Vec<&str> = attribute.splitn(2, '=').collect();
        let key = pieces[0].to_lowercase();
        let value = pieces[1];
        if value.is_empty() {
            match key.as_str() {
                "by" => return Err(ParseError::InvalidField(attribute)),
                _ => continue,
            }
        }
        match key.as_str() {
            "by" => parsed_xfcc.by.push_str(value),
            "hash" => parsed_xfcc.hash = Some(value.to_string()),
            "cert" => parsed_xfcc.cert = Some(value.to_string()),
            "chain" => parsed_xfcc.chain = Some(value.to_string()),
            "subject" => {
                parsed_xfcc.subject = Some(String::from(
                    value
                        .strip_prefix('"')
                        .unwrap_or("")
                        .strip_suffix('"')
                        .unwrap_or(""),
                ))
            }
            "uri" => parsed_xfcc.append_uri(value),
            "dns" => parsed_xfcc.append_dns(value),
            _ => return Err(ParseError::InvalidField(attribute)),
        }
    }
    Ok(parsed_xfcc)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_parse_single_xfcc_handles_envoy_examples() {
        let example_inputs: &[(&str, Result<XForwardedClientCert, ParseError>)] = &[
            ("By=http://frontend.lyft.com;Hash=468ed33be74eee6556d90c0149c1309e9ba61d6425303443c0748a02dd8de688;Subject=\"/C=US/ST=CA/L=San Francisco/OU=Lyft/CN=Test Client\";URI=http://testclient.lyft.com",
            Ok(XForwardedClientCert {
                by: String::from("http://frontend.lyft.com"),
                hash: Some(String::from(
                    "468ed33be74eee6556d90c0149c1309e9ba61d6425303443c0748a02dd8de688",
                )),
                cert: None,
                chain: None,
                subject: Some(String::from(
                    "/C=US/ST=CA/L=San Francisco/OU=Lyft/CN=Test Client",
                )),
                uri: Some(vec![String::from("http://testclient.lyft.com")]),
                dns: None,
            })),
            ("By=http://frontend.lyft.com;Hash=468ed33be74eee6556d90c0149c1309e9ba61d6425303443c0748a02dd8de688;Subject=\"/C=US/ST=CA/L=San Francisco/OU=Lyft/CN=Test Client\";URI=http://testclient.lyft.com;DNS=lyft.com;DNS=www.lyft.com", 
            Ok(XForwardedClientCert {
                by: String::from("http://frontend.lyft.com"),
                hash: Some(String::from(
                    "468ed33be74eee6556d90c0149c1309e9ba61d6425303443c0748a02dd8de688",
                )),
                cert: None,
                chain: None,
                subject: Some(String::from(
                    "/C=US/ST=CA/L=San Francisco/OU=Lyft/CN=Test Client",
                )),
                uri: Some(vec![String::from("http://testclient.lyft.com")]),
                dns: Some(vec![String::from("lyft.com"), String::from("www.lyft.com")]),
            })),
            ("By=http://frontend.lyft.com;Hash=468ed33be74eee6556d90c0149c1309e9ba61d6425303443c0748a02dd8de688;URI=http://testclient.lyft.com",
            Ok(XForwardedClientCert {
                by: String::from("http://frontend.lyft.com"),
                hash: Some(String::from(
                    "468ed33be74eee6556d90c0149c1309e9ba61d6425303443c0748a02dd8de688",
                )),
                cert: None,
                chain: None,
                subject: None,
                uri: Some(vec![String::from("http://testclient.lyft.com")]),
                dns: None,
            })),
            ("By=http://backend.lyft.com;Hash=9ba61d6425303443c0748a02dd8de688468ed33be74eee6556d90c0149c1309e;URI=http://frontend.lyft.com",
            Ok(XForwardedClientCert {
                by: String::from("http://backend.lyft.com"),
                hash: Some(String::from(
                    "9ba61d6425303443c0748a02dd8de688468ed33be74eee6556d90c0149c1309e",
                )),
                cert: None,
                chain: None,
                subject: None,
                uri: Some(vec![String::from("http://frontend.lyft.com")]),
                dns: None,
            })),
            ("By=http://frontend.lyft.com;Hash=468ed33be74eee6556d90c0149c1309e9ba61d6425303443c0748a02dd8de688;Subject=\"/C=US/ST=CA/L=San Francisco/O=Lyft, Inc./CN=Test Client\";URI=http://testclient.lyft.com;DNS=lyft.com;DNS=www.lyft.com",
            Ok(XForwardedClientCert {
                by: String::from("http://frontend.lyft.com"),
                hash: Some(String::from(
                    "468ed33be74eee6556d90c0149c1309e9ba61d6425303443c0748a02dd8de688",
                )),
                cert: None,
                chain: None,
                subject: Some(String::from(
                    "/C=US/ST=CA/L=San Francisco/O=Lyft, Inc./CN=Test Client",
                )),
                uri: Some(vec![String::from("http://testclient.lyft.com")]),
                dns: Some(vec![String::from("lyft.com"), String::from("www.lyft.com")]),
            })),
            ("By=http://frontend.lyft.com;Hash=468ed33be74eee6556d90c0149c1309e9ba61d6425303443c0748a02dd8de688;Subject=\"/C=US/ST=CA/L=San Francisco/O=Lyft, Inc./CN=Test Client;URI=http://testclient.lyft.com;DNS=lyft.com;DNS=www.lyft.com",
            Err(ParseError::QuotedStringNotTerminated)),
            ("By=http://frontend.lyft.com;NotAField=foo",
            Err(ParseError::InvalidField(String::from("NotAField=foo")))),
            ("By=;URI=http://testclient.lyft.com",
            Err(ParseError::InvalidField(String::from("By=")))),
            ("By=http://frontend.lyft.com;URI=;DNS=lyft.com", // Seen in the wild, apparently some of these can
                                                // be specified without a value
            Ok(XForwardedClientCert {
                by: String::from("http://frontend.lyft.com"),
                hash: None,
                cert: None,
                chain: None,
                subject: None,
                uri: None,
                dns: Some(vec![String::from("lyft.com")]),
            })),
            ("By=http://frontend.lyft.com;DNS=lyft.com;Cert=FakeCertData;Chain=FakeChainData",
            Ok(XForwardedClientCert {
                by: String::from("http://frontend.lyft.com"),
                hash: None,
                cert: Some(String::from("FakeCertData")),
                chain: Some(String::from("FakeChainData")),
                subject: None,
                uri: None,
                dns: Some(vec![String::from("lyft.com")]),
            })),
            ("By=http://frontend.lyft.com;Hash=468ed33be74eee6556d90c0149c1309e9ba61d6425303443c0748a02dd8de688;Subject=\"/C=US/ST=CA/L=San Francisco/O=Lyft, Inc./CN=Test Client\";URI=http://testmesh.lyft.com;URI=http://testclient.lyft.com;DNS=lyft.com;DNS=www.lyft.com",
            Ok(XForwardedClientCert {
                by: String::from("http://frontend.lyft.com"),
                hash: Some(String::from(
                    "468ed33be74eee6556d90c0149c1309e9ba61d6425303443c0748a02dd8de688",
                )),
                cert: None,
                chain: None,
                subject: Some(String::from(
                    "/C=US/ST=CA/L=San Francisco/O=Lyft, Inc./CN=Test Client",
                )),
                uri: Some(vec![String::from("http://testmesh.lyft.com"), String::from("http://testclient.lyft.com")]),
                dns: Some(vec![String::from("lyft.com"), String::from("www.lyft.com")]),
            })),
        ];
        for (input, want) in example_inputs.iter() {
            assert_eq!(parse_single_xfcc(input), *want);
        }
    }

    #[test]
    fn test_xfcc_getters_work() {
        let example = XForwardedClientCert {
            by: String::from("by"),
            hash: Some(String::from("hash")),
            cert: Some(String::from("cert")),
            chain: Some(String::from("chain")),
            subject: Some(String::from("subject")),
            uri: Some(vec![String::from("uri")]),
            dns: Some(vec![String::from("dns")]),
        };
        assert_eq!("by", example.get_by());
        assert_eq!(Some("hash"), example.get_hash());
        assert_eq!(Some("cert"), example.get_cert_pem());
        assert_eq!(Some("chain"), example.get_cert_chain_pem());
        assert_eq!(Some("subject"), example.get_subject());
        assert_eq!(Some(&vec![String::from("uri")]), example.get_all_uris());
        assert_eq!(Some(&vec![String::from("dns")]), example.get_all_dns());

        let example = XForwardedClientCert {
            by: String::from("by"),
            hash: None,
            cert: None,
            chain: None,
            subject: None,
            uri: None,
            dns: None,
        };
        assert_eq!("by", example.get_by());
        assert_eq!(None, example.get_hash());
        assert_eq!(None, example.get_cert_pem());
        assert_eq!(None, example.get_cert_chain_pem());
        assert_eq!(None, example.get_subject());
        assert_eq!(None, example.get_all_uris());
        assert_eq!(None, example.get_all_dns());
    }

    #[test]
    fn test_parse_xfcc_list() {
        let example_inputs = [
            ("By=http://frontend.lyft.com;Hash=468ed33be74eee6556d90c0149c1309e9ba61d6425303443c0748a02dd8de688;URI=http://testclient.lyft.com,By=http://backend.lyft.com;Hash=9ba61d6425303443c0748a02dd8de688468ed33be74eee6556d90c0149c1309e;URI=http://frontend.lyft.com",
            Ok(vec![
                XForwardedClientCert {
                    by: String::from("http://frontend.lyft.com"),
                    hash: Some(String::from(
                        "468ed33be74eee6556d90c0149c1309e9ba61d6425303443c0748a02dd8de688",
                    )),
                    uri: Some(vec![String::from("http://testclient.lyft.com")]),
                    cert: None,
                    chain: None,
                    subject: None,
                    dns: None,
                },
                XForwardedClientCert {
                    by: String::from("http://backend.lyft.com"),
                    hash: Some(String::from(
                        "9ba61d6425303443c0748a02dd8de688468ed33be74eee6556d90c0149c1309e",
                    )),
                    uri: Some(vec![String::from("http://frontend.lyft.com")]),
                    cert: None,
                    chain: None,
                    subject: None,
                    dns: None,
                },
            ])),
            ("By=http://frontend.lyft.com;Hash=468ed33be74eee6556d90c0149c1309e9ba61d6425303443c0748a02dd8de688;URI=http://testclient.lyft.com,By=http://backend.lyft.com;Hash=9ba61d6425303443c0748a02dd8de688468ed33be74eee6556d90c0149c1309e;URI=http://frontend.lyft.com;NotAField=foo",
            Err(ParseError::InvalidField(String::from("NotAField=foo")))),
        ];

        for (input, want) in example_inputs.iter() {
            assert_eq!(parse_xfcc_list(input), *want);
        }
    }

    #[test]
    fn test_quote_aware_split() {
        let example_inputs: &[((&str, char, usize), Result<Vec<String>, ParseError>)] = &[
            (("By=http://frontend.lyft.com;Hash=468ed33be74eee6556d90c0149c1309e9ba61d6425303443c0748a02dd8de688;Subject=\"/C=US/ST=CA/L=San Francisco/OU=Lyft/CN=Test Client\";URI=http://testclient.lyft.com", ';', 0),
            Ok(vec![
                String::from("By=http://frontend.lyft.com"),
                String::from(
                    "Hash=468ed33be74eee6556d90c0149c1309e9ba61d6425303443c0748a02dd8de688",
                ),
                String::from("Subject=\"/C=US/ST=CA/L=San Francisco/OU=Lyft/CN=Test Client\""),
                String::from("URI=http://testclient.lyft.com"),
            ])),
            (("By=http://frontend.lyft.com;Hash=468ed33be74eee6556d90c0149c1309e9ba61d6425303443c0748a02dd8de688;Subject=\"/C=US/ST=CA/L=San Francisco/OU=0:Lyft;1:Frontend/CN=Test Client\";URI=http://testclient.lyft.com", ';', 0),
            Ok(vec![
                String::from("By=http://frontend.lyft.com"),
                String::from(
                    "Hash=468ed33be74eee6556d90c0149c1309e9ba61d6425303443c0748a02dd8de688",
                ),
                String::from(
                    "Subject=\"/C=US/ST=CA/L=San Francisco/OU=0:Lyft;1:Frontend/CN=Test Client\"",
                ),
                String::from("URI=http://testclient.lyft.com"),
            ])),
        ];
        for (input, want) in example_inputs.iter() {
            assert_eq!(quote_aware_split(input.0, input.1, input.2), *want)
        }
    }

    #[test]
    fn test_name_parsing() {
        let test_cases: &[(&str, Result<Name, ParseError>)] = &[
            ("/C=US/ST=CA/L=San Francisco/OU=0:Lyft;1:Frontend/CN=Test Client",
            Ok(Name {
                country: Some(vec![String::from("US")]),
                province: Some(vec![String::from("CA")]),
                locality: Some(vec![String::from("San Francisco")]),
                organizational_unit: Some(vec![String::from("0:Lyft;1:Frontend")]),
                common_name: Some(String::from("Test Client")),
                ..Name::default()
            })),
            ("/C=US/ST=CA/L=San Francisco/OU=0:Lyft;1:Frontend/CN=Test Client/STREET=123 Main St",
            Ok(Name {
                country: Some(vec![String::from("US")]),
                province: Some(vec![String::from("CA")]),
                locality: Some(vec![String::from("San Francisco")]),
                organizational_unit: Some(vec![String::from("0:Lyft;1:Frontend")]),
                common_name: Some(String::from("Test Client")),
                street_address: Some(vec![String::from("123 Main St")]),
                ..Name::default()
            })),
            ("/C=/ST=CA/L=San Francisco/OU=0:Lyft;1:Frontend/CN=Test Client/STREET=123 Main St",
            Ok(Name {
                province: Some(vec![String::from("CA")]),
                locality: Some(vec![String::from("San Francisco")]),
                organizational_unit: Some(vec![String::from("0:Lyft;1:Frontend")]),
                common_name: Some(String::from("Test Client")),
                street_address: Some(vec![String::from("123 Main St")]),
                ..Name::default()
            })),
            ("/C=US/ST=CA/L=San Francisco/OU=0:Lyft;1:Frontend/CN=Test Client/STREET=123 Main St/C=GB/OU=Computer Science/O=University College London",
            Ok(Name {
                country: Some(vec![String::from("US"), String::from("GB")]),
                province: Some(vec![String::from("CA")]),
                locality: Some(vec![String::from("San Francisco")]),
                organizational_unit: Some(vec![String::from("0:Lyft;1:Frontend"), String::from("Computer Science")]),
                common_name: Some(String::from("Test Client")),
                street_address: Some(vec![String::from("123 Main St")]),
                organization: Some(vec![String::from("University College London")]),
                ..Name::default()
            })),
            ("/D=Foo/C=US/ST=CA/L=San Francisco/OU=0:Lyft;1:Frontend/CN=Test Client/STREET=123 Main St",
            Err(ParseError::NameParseFailed(String::from("D=Foo")))
            ),
        ];
        for (input, expected) in test_cases.iter() {
            let got: Result<Name, ParseError> = input.parse();
            assert_eq!(&got, expected);
        }
    }
}
